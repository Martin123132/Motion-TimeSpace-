# Cosmology Comparison Replication Kit

This kit packages the original comparison notebooks into standalone scripts so
others can reproduce the plots and statistics exactly as originally shared. The
physics formulas, parameter choices, and χ² calculations are unchanged—only the
file layout and instructions have been tidied up for clarity.

## Requirements

* Python 3.10 or later
* Recommended environment: a virtual environment created with `python -m venv`
* Python packages (install with `pip install -r requirements.txt`):
  * `numpy`
  * `pandas`
  * `matplotlib`
  * `requests`
  * `scipy`

## Getting Started

1. **Create and activate a virtual environment (optional, but recommended)**
   ```bash
   python -m venv .venv
   source .venv/bin/activate  # Windows: .venv\\Scripts\\activate
   ```
2. **Install dependencies**
   ```bash
   pip install -r requirements.txt
   ```
3. **Run any script** by invoking it with Python from the repository root. Each
   script saves no files and reproduces the original console output and plots.

## Available Scripts

All scripts live in `replication_kit/scripts/` and can be launched with
`python replication_kit/scripts/<script_name>.py`.

| Script | Description |
| ------ | ----------- |
| `pantheon_shoes_chi2.py` | Downloads the Pantheon+ SH0ES dataset and compares ΛCDM and MTS–PGF distance moduli with χ² diagnostics and residual plots. |
| `hz_fixed_prior_comparison.py` | Recreates the fixed-prior H(z) visual comparison with χ² diagnostics between ΛCDM and MTS-5. |
| `bao_fixed_prior_symmetry.py` | Implements the “fair fixed-prior” BAO comparison where both models share identical equations except for α. |
| `bao_best_fit_symmetry.py` | Performs best-fit BAO comparisons (ΛCDM vs MTS-5) with the shared Dᵥ/rₛ integral and χ² evaluation. |
| `pantheon_best_fit_symmetry.py` | Executes the fair Pantheon+ supernova fit using identical luminosity distance integrals for both models and reports the χ² results. |

## Reproducing the Full Flow

To replicate the entire analysis sequence from the original notes:

1. Run `pantheon_shoes_chi2.py` to validate the Pantheon+ SH0ES distance-modulus
   comparison with residual plots.
2. Execute `hz_fixed_prior_comparison.py` for the visual H(z) comparison and χ²
   diagnostics.
3. Launch `bao_fixed_prior_symmetry.py` to inspect the BAO ladder under fixed
   priors with perfectly symmetric equations.
4. Use `bao_best_fit_symmetry.py` to reproduce the fair BAO best-fit results.
5. Finish with `pantheon_best_fit_symmetry.py` for the Pantheon+ fair best-fit
   comparison.

Each step prints the same textual summaries as the original snippets, ensuring
anyone can follow the workflow linearly without editing the source code.

replication_kit/requirements.txt
New
+5
-0

matplotlib
numpy
pandas
requests
scipy
replication_kit/scripts/bao_best_fit_symmetry.py
New
+125
-0

"""Best-fit BAO comparison with identical Dᵥ/rₛ equations."""

from __future__ import annotations

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# --- BAO ladder dataset (from original document)
bao = np.array(
    [
        [0.106, 3.047, 0.137],
        [0.35, 8.88, 0.17],
        [0.57, 13.67, 0.22],
        [1.52, 26.0, 0.7],
        [2.34, 36.3, 1.8],
    ]
)
z_bao, dv_obs, dv_err = bao.T
c = 299_792.458  # km/s
rs = 147.0  # Mpc


# --- Hubble function (ΛCDM or MTS form)
def H_model(z_val, H0, omega_m, alpha=1.0):
    return H0 * np.sqrt(
        omega_m * (1 + z_val) ** (3 * alpha)
        + (1 - omega_m) * (1 + z_val) ** (2 - alpha)
    )


# --- Dv/rs integral
def Dv_over_rs(Hf, redshift):
    zs = np.linspace(0, redshift, 600)
    hz = Hf(zs)
    d_c = np.trapezoid(c / hz, zs)
    dv = (( (1 + redshift) ** 2 * d_c ** 2 * c * redshift / Hf(redshift) ) ** (1 / 3))
    return dv / rs


# --- Curve-fit helpers
def model_LCDM(z_val, H0, omega_m):
    return np.array(
        [Dv_over_rs(lambda zz: H_model(zz, H0, omega_m, 1.0), zi) for zi in z_val]
    )


def model_MTS(z_val, H0, omega_m, alpha):
    return np.array(
        [Dv_over_rs(lambda zz: H_model(zz, H0, omega_m, alpha), zi) for zi in z_val]
    )


# --- Fit both models
popt_LCDM, _ = curve_fit(
    model_LCDM,
    z_bao,
    dv_obs,
    sigma=dv_err,
    p0=[70, 0.3],
    bounds=([50, 0.05], [90, 0.5]),
)
popt_MTS, _ = curve_fit(
    model_MTS,
    z_bao,
    dv_obs,
    sigma=dv_err,
    p0=[73, 0.3, 0.8],
    bounds=([50, 0.05, 0.6], [90, 0.5, 1.2]),
)


# --- Compute predictions and χ²
dv_LCDM = model_LCDM(z_bao, *popt_LCDM)
dv_MTS = model_MTS(z_bao, *popt_MTS)
chi2_LCDM = np.sum(((dv_obs - dv_LCDM) / dv_err) ** 2)
chi2_MTS = np.sum(((dv_obs - dv_MTS) / dv_err) ** 2)
delta_chi2 = chi2_MTS - chi2_LCDM


# --- Plot
z_fit = np.linspace(0, 2.5, 200)
plt.errorbar(z_bao, dv_obs, yerr=dv_err, fmt="ko", label="BAO data")
plt.plot(
    z_fit,
    model_LCDM(z_fit, *popt_LCDM),
    "orange",
    ls="--",
    label=f"ΛCDM  H₀={popt_LCDM[0]:.2f}, Ωₘ={popt_LCDM[1]:.3f}, α=1",
)
plt.plot(
    z_fit,
    model_MTS(z_fit, *popt_MTS),
    "b-",
    lw=2,
    label=(
        f"MTS-5  H₀={popt_MTS[0]:.2f}, Ωₘ={popt_MTS[1]:.3f}, α={popt_MTS[2]:.3f}"
    ),
)
plt.xlabel("Redshift z")
plt.ylabel("Dᵥ / rₛ")
plt.title("Fair BAO Fit — ΛCDM vs MTS-5 (Best Fits)")
plt.legend()
plt.grid(alpha=0.4)
plt.show()


# --- Print results
print("==============================================")
print("  FAIR BEST-FIT BAO COMPARISON (no AIC/BIC)")
print("==============================================")
print(
    f"ΛCDM best-fit:  H₀={popt_LCDM[0]:.3f},  Ωₘ={popt_LCDM[1]:.3f},  α=1.000 (fixed)"
)
print(
    f"MTS-5 best-fit: H₀={popt_MTS[0]:.3f},  Ωₘ={popt_MTS[1]:.3f},  α={popt_MTS[2]:.3f}"
)
print("----------------------------------------------")
print(f"ΛCDM χ² = {chi2_LCDM:.3f}")
print(f"MTS-5  χ² = {chi2_MTS:.3f}")
print(f"Δχ² (MTS–ΛCDM) = {delta_chi2:+.3f}")
print("==============================================")
print("Parameter accounting:")
print("ΛCDM : 2 free (H₀, Ωₘ) + α fixed (1.0)")
print("MTS-5: 3 free (H₀, Ωₘ, α)  – all physical parameters")
replication_kit/scripts/bao_fixed_prior_symmetry.py
New
+102
-0

"""Fair fixed-prior BAO comparison with symmetric equations."""

from __future__ import annotations

import numpy as np
import matplotlib.pyplot as plt

# Observed BAO ladder data (z, D_V/rs, σ)
bao_data = np.array(
    [
        [0.106, 3.047, 0.137],
        [0.35, 8.88, 0.17],
        [0.57, 13.67, 0.22],
        [1.52, 26.0, 0.70],
        [2.34, 36.3, 1.80],
    ]
)
z_bao, DV_obs, DV_err = bao_data.T
rs = 147.0  # sound horizon (Mpc)
c = 299_792.458  # km/s

# Shared priors
OMEGA_M_FIXED = 0.30
OMEGA_L_FIXED = 1 - OMEGA_M_FIXED

# Free parameter for both
H0_LCDM = 70.0
H0_MTS5 = 73.0

# MTS curvature transmissibility (fixed physical)
ALPHA_LCDM = 1.0
ALPHA_MTS5 = 0.74


# H(z) definitions (identical except for α)
def H_generic(z_val, H0, omega_m, alpha):
    omega_lambda = 1 - omega_m
    return H0 * np.sqrt(
        omega_m * (1 + z_val) ** (3 * alpha)
        + omega_lambda * (1 + z_val) ** (2 - alpha)
    )


def DV_over_rs(model_H, redshift):
    zs = np.linspace(0, redshift, 800)
    d_c = np.trapezoid(c / model_H(zs), zs)
    dv = (( (1 + redshift) ** 2 * d_c ** 2 * c * redshift / model_H(redshift) ) ** (1 / 3))
    return dv / rs


# Compute D_V/rs for each model
H_LCDM = lambda zz: H_generic(zz, H0_LCDM, OMEGA_M_FIXED, ALPHA_LCDM)
H_MTS5 = lambda zz: H_generic(zz, H0_MTS5, OMEGA_M_FIXED, ALPHA_MTS5)

DV_LCDM = np.array([DV_over_rs(H_LCDM, zi) for zi in z_bao])
DV_MTS5 = np.array([DV_over_rs(H_MTS5, zi) for zi in z_bao])

# χ² diagnostics
chi2_LCDM = np.sum(((DV_obs - DV_LCDM) / DV_err) ** 2)
chi2_MTS5 = np.sum(((DV_obs - DV_MTS5) / DV_err) ** 2)
delta_chi2 = chi2_MTS5 - chi2_LCDM

# Plot
plt.figure(figsize=(8, 6))
plt.errorbar(z_bao, DV_obs, yerr=DV_err, fmt="ko", capsize=4, label="BAO data (Dᵥ/rs)")
z_fit = np.linspace(0, 2.5, 400)
plt.plot(
    z_fit,
    [DV_over_rs(H_LCDM, zz) for zz in z_fit],
    "orange",
    ls="--",
    lw=2,
    label=f"ΛCDM  H₀={H0_LCDM:.1f}, Ωₘ={OMEGA_M_FIXED:.2f}, α=1.00",
)
plt.plot(
    z_fit,
    [DV_over_rs(H_MTS5, zz) for zz in z_fit],
    "b-",
    lw=2,
    label=f"MTS-5  H₀={H0_MTS5:.1f}, Ωₘ={OMEGA_M_FIXED:.2f}, α={ALPHA_MTS5:.2f}",
)
plt.xlabel("Redshift z")
plt.ylabel("Dᵥ / rₛ")
plt.title("ΛCDM vs MTS-5 — BAO Ladder (Identical Equations, Fixed Priors)")
plt.legend()
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()

# Results summary
print("=====================================================")
print("  BAO FAIR COMPARISON  —  Symmetric Equations Only  ")
print("=====================================================")
print(f"ΛCDM : H₀={H0_LCDM:.1f}, Ωₘ={OMEGA_M_FIXED:.2f}, α={ALPHA_LCDM:.2f}")
print(f"MTS-5: H₀={H0_MTS5:.1f}, Ωₘ={OMEGA_M_FIXED:.2f}, α={ALPHA_MTS5:.2f}")
print("-----------------------------------------------------")
print(f"ΛCDM  χ² = {chi2_LCDM:.3f}")
print(f"MTS-5 χ² = {chi2_MTS5:.3f}")
print(f"Δχ² (MTS–ΛCDM) = {delta_chi2:+.3f}")
print("-----------------------------------------------------")
print("Both models share identical Ωₘ, ΩΛ, rₛ, and integration method.")
print("Only α differs — geometric transmissibility vs static expansion.")
replication_kit/scripts/hz_fixed_prior_comparison.py
New
+106
-0

"""ΛCDM vs MTS-5 fixed-prior H(z) comparison with χ² diagnostics."""

from __future__ import annotations

import numpy as np
import matplotlib.pyplot as plt

# --------------------------------------------------------------
# 1. Observational H(z) data
# --------------------------------------------------------------
hz_data = np.array(
    [
        [0.07, 69.0, 19.6],
        [0.12, 68.6, 26.2],
        [0.17, 83.0, 8.0],
        [0.27, 77.0, 14.0],
        [0.40, 95.0, 17.0],
        [0.48, 97.0, 62.0],
        [0.88, 90.0, 40.0],
        [1.30, 168.0, 17.0],
        [1.43, 177.0, 18.0],
        [1.53, 140.0, 14.0],
        [1.75, 202.0, 40.0],
    ]
)
z, H_obs, H_err = hz_data.T

# --------------------------------------------------------------
# 2. Models and fixed parameters
# --------------------------------------------------------------
H0_LCDM, OMEGA_M_LCDM = 70.19, 0.315
H0_MTS5, OMEGA_M_MTS5, ALPHA_MTS5 = 73.61, 0.30, 0.74


def H_LCDM(z_val):
    omega_lambda = 1 - OMEGA_M_LCDM
    return H0_LCDM * np.sqrt(OMEGA_M_LCDM * (1 + z_val) ** 3 + omega_lambda)


def H_MTS5(z_val):
    omega_lambda = 1 - OMEGA_M_MTS5
    return H0_MTS5 * np.sqrt(
        OMEGA_M_MTS5 * (1 + z_val) ** (3 * ALPHA_MTS5)
        + omega_lambda * (1 + z_val) ** (2 - ALPHA_MTS5)
    )


# --------------------------------------------------------------
# 3. Compute χ² for each model (for transparency)
# --------------------------------------------------------------
def chisq(model):
    return np.sum(((H_obs - model(z)) / H_err) ** 2)


chi2_LCDM = chisq(H_LCDM)
chi2_MTS5 = chisq(H_MTS5)
Delta_chi2 = chi2_MTS5 - chi2_LCDM

# --------------------------------------------------------------
# 4. Plot the comparison
# --------------------------------------------------------------
z_fit = np.linspace(0, 2.0, 400)
plt.figure(figsize=(8, 6))
plt.errorbar(z, H_obs, yerr=H_err, fmt="ko", capsize=4, label="H(z) data")
plt.plot(
    z_fit,
    H_LCDM(z_fit),
    "orange",
    ls="--",
    lw=2,
    label=f"ΛCDM  H₀={H0_LCDM:.2f}, Ωₘ={OMEGA_M_LCDM:.3f}",
)
plt.plot(
    z_fit,
    H_MTS5(z_fit),
    "b-",
    lw=2,
    label=f"MTS-5  H₀={H0_MTS5:.2f}, Ωₘ={OMEGA_M_MTS5:.3f}, α={ALPHA_MTS5:.2f}",
)
plt.xlabel("Redshift z")
plt.ylabel("H(z)  [km s⁻¹ Mpc⁻¹]")
plt.title("ΛCDM vs MTS-5 — Fixed Priors with χ² Diagnostic")
plt.legend()
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()

# --------------------------------------------------------------
# 5. Print transparent results
# --------------------------------------------------------------
print("===============================================")
print("  FIXED–PRIOR COMPARISON  —  χ² Diagnostic Only")
print("===============================================")
print(f"ΛCDM :  H₀={H0_LCDM:.2f}, Ωₘ={OMEGA_M_LCDM:.3f}, α=1.00 (by def.)")
print(
    f"MTS-5:  H₀={H0_MTS5:.2f}, Ωₘ={OMEGA_M_MTS5:.3f}, α={ALPHA_MTS5:.2f}"
)
print("-----------------------------------------------")
print(f"ΛCDM  χ² = {chi2_LCDM:.3f}")
print(f"MTS-5 χ² = {chi2_MTS5:.3f}")
print(f"Δχ² (MTS–ΛCDM) = {Delta_chi2:+.3f}")
print("===============================================")
print("Parameter accounting:")
print("ΛCDM : 1 free (H₀) + ~7 fixed/derived")
print("MTS-5: 1 free (H₀) + 2 fixed physical (Ωₘ, α)")
print("χ² shown for context only — not used as scoring metric.")
replication_kit/scripts/pantheon_best_fit_symmetry.py
New
+131
-0

"""Fair Pantheon+ supernova best-fit comparison (ΛCDM vs MTS-5)."""

from __future__ import annotations

import io

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import requests
from scipy.optimize import curve_fit

# --- Constants
c = 299_792.458  # km/s

# --- Load Pantheon+ SH0ES dataset
url = "https://raw.githubusercontent.com/PantheonPlusSH0ES/DataRelease/main/Pantheon+_Data/4_DISTANCES_AND_COVAR/Pantheon+SH0ES.dat"
response = requests.get(url, timeout=60)
response.raise_for_status()

df = pd.read_csv(io.StringIO(response.text), sep=r"\s+", comment="#")
z = df["zCMB"].values
mu_obs = df["MU_SH0ES"].values
mu_err = df["MU_SH0ES_ERR_DIAG"].values


# --- Hubble function (shared)
def H_model(z_val, H0, omega_m, alpha=1.0):
    return H0 * np.sqrt(
        omega_m * (1 + z_val) ** (3 * alpha)
        + (1 - omega_m) * (1 + z_val) ** (2 - alpha)
    )


# --- Distance modulus model
def mu_model(z_vals, H0, omega_m, alpha):
    mus = []
    for zi in z_vals:
        zs = np.linspace(0, zi, 600)
        hz = H_model(zs, H0, omega_m, alpha)
        d_c = np.trapezoid(c / hz, zs)
        d_l = (1 + zi) * d_c
        mus.append(5 * np.log10(d_l) + 25)
    return np.array(mus)


# --- Fit ΛCDM (α fixed = 1)
def model_LCDM(z_vals, H0):
    return mu_model(z_vals, H0, 0.30, 1.0)


# --- Fit MTS-5 (α free)
def model_MTS(z_vals, H0, alpha):
    return mu_model(z_vals, H0, 0.30, alpha)


# --- Curve fits
popt_LCDM, _ = curve_fit(
    model_LCDM,
    z,
    mu_obs,
    sigma=mu_err,
    p0=[70],
    bounds=([50], [90]),
)
popt_MTS, _ = curve_fit(
    model_MTS,
    z,
    mu_obs,
    sigma=mu_err,
    p0=[73, 0.8],
    bounds=([50, 0.6], [90, 1.2]),
)


# --- Predictions and χ²
mu_LCDM = model_LCDM(z, *popt_LCDM)
mu_MTS = model_MTS(z, *popt_MTS)
chi2_LCDM = np.sum(((mu_obs - mu_LCDM) / mu_err) ** 2)
chi2_MTS = np.sum(((mu_obs - mu_MTS) / mu_err) ** 2)
delta_chi2 = chi2_MTS - chi2_LCDM


# --- Plot subset for clarity
sel = slice(None, None, 20)  # thin points for visibility
plt.errorbar(
    z[sel],
    mu_obs[sel],
    yerr=mu_err[sel],
    fmt=".",
    color="k",
    alpha=0.4,
    label="Pantheon+ data",
)
zfit = np.linspace(0, 2.3, 400)
plt.plot(
    zfit,
    model_LCDM(zfit, *popt_LCDM),
    "orange",
    ls="--",
    label=f"ΛCDM  H₀={popt_LCDM[0]:.2f}, Ωₘ=0.30, α=1",
)
plt.plot(
    zfit,
    model_MTS(zfit, *popt_MTS),
    "b-",
    lw=2,
    label=f"MTS-5  H₀={popt_MTS[0]:.2f}, Ωₘ=0.30, α={popt_MTS[1]:.3f}",
)
plt.xlabel("Redshift z")
plt.ylabel("μ (mag)")
plt.title("Fair Pantheon+ Fit — ΛCDM vs MTS-5 (Identical Equations)")
plt.legend()
plt.grid(alpha=0.3)
plt.show()


# --- Results
print("==============================================")
print("  FAIR BEST-FIT PANTHEON+ COMPARISON (χ² only)")
print("==============================================")
print(f"ΛCDM best-fit:  H₀={popt_LCDM[0]:.3f}, Ωₘ=0.30, α=1.000 (fixed)")
print(f"MTS-5 best-fit: H₀={popt_MTS[0]:.3f}, Ωₘ=0.30, α={popt_MTS[1]:.3f}")
print("----------------------------------------------")
print(f"ΛCDM χ² = {chi2_LCDM:.3f}")
print(f"MTS-5  χ² = {chi2_MTS:.3f}")
print(f"Δχ² (MTS–ΛCDM) = {delta_chi2:+.3f}")
print("==============================================")
print("Parameter accounting:")
print("ΛCDM : 1 free (H₀) + Ωₘ fixed, α=1 fixed")
print("MTS-5: 2 free (H₀, α) + Ωₘ fixed (physical)")
replication_kit/scripts/pantheon_shoes_chi2.py
New
+139
-0

